<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/png" href="./icon.png">
    <title>오목</title>
    <style>
        :root { --primary: #34495e; --accent: #e74c3c; --bg: #f4f7f6; --success: #27ae60; --warning: #f39c12; }
        body { 
            display: flex; flex-direction: column; align-items: center; 
            background-color: var(--bg); font-family: 'Malgun Gothic', sans-serif; 
            margin: 0; padding: 10px; box-sizing: border-box;
            touch-action: manipulation;
        }
        h1 { font-size: 1.4rem; margin: 10px 0; color: var(--primary); }
        
        /* 상단 기본 설정 패널 */
        .controls { 
            margin-bottom: 12px; padding: 12px; background: white; 
            border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); 
            display: flex; flex-direction: column; gap: 10px; 
            width: 100%; max-width: 600px; box-sizing: border-box;
        }

        .config-row { 
            display: flex; gap: 12px; align-items: center; 
            flex-wrap: wrap; justify-content: center; font-size: 0.85rem; 
        }
        .config-row label, .config-row div { white-space: nowrap; }

        /* 봇 전용 패널 */
        .bot-panel { 
            background: #ebf2f6; padding: 12px; border-radius: 8px; 
            display: flex; flex-direction: column; gap: 10px; 
        }
        .bot-header { display: flex; align-items: center; gap: 10px; border-bottom: 1px solid #d0dbe5; padding-bottom: 8px; font-weight: bold; font-size: 0.9rem; }

        .slider-box { 
            display: flex; align-items: center; gap: 8px; 
            font-size: 0.85rem; flex: 1; min-width: 140px;
            white-space: nowrap; width: 100%;
        }
        input[type="range"] { flex: 1; cursor: pointer; height: 18px; min-width: 50px; }

        #status { font-size: 1.1rem; font-weight: bold; margin: 5px 0; color: var(--primary); }
        #timer { font-family: monospace; color: var(--accent); font-size: 1.6rem; font-weight: bold; }
        
        .canvas-container { width: 100%; max-width: 600px; aspect-ratio: 1 / 1; display: flex; justify-content: center; position: relative; }
        canvas { background-color: #e3a05b; box-shadow: 0 8px 25px rgba(0,0,0,0.2); cursor: pointer; border-radius: 4px; width: 100%; height: auto; }

        /* 하단 버튼 바 */
        .buttons { margin-top: 15px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; width: 100%; max-width: 600px; }
        button { flex: 1; min-width: 80px; padding: 12px 10px; font-size: 0.9rem; cursor: pointer; background-color: var(--primary); color: white; border: none; border-radius: 6px; font-weight: bold; transition: background 0.2s; }
        
        /* 상태별 버튼 색상 */
        #actionBtn.start { background-color: var(--success); }
        #actionBtn.pause { background-color: var(--warning); }
        #actionBtn.resume { background-color: var(--success); }
        
        button:disabled { background-color: #bdc3c7; cursor: not-allowed; }
        
        .forbidden-msg { color: var(--accent); font-size: 1.1rem; height: 26px; font-weight: bold; margin-top: 5px; text-align: center; }
        .check-group { border: 1px solid #ddd; padding: 4px 8px; border-radius: 5px; background: #fff; display: flex; gap: 8px; }

        /* 모바일 대응 */
        @media (max-width: 550px) {
            .bot-panel .config-row { flex-direction: column; align-items: stretch; gap: 10px; }
            .slider-box { width: 100%; }
            #botPreset { width: 100%; }
        }
    </style>
</head>
<body>

    <h1>오목 </h1>
    
    <div class="controls">
        <div class="config-row">
            <div>제한시간: <input type="number" id="timeInput" value="30" min="5" style="width:35px">s</div>
            <div class="check-group">
                <label><input type="checkbox" id="blackForbidden" checked> 흑 금수</label>
                <label><input type="checkbox" id="whiteForbidden"> 백 금수</label>
            </div>
        </div>

        <div class="bot-panel">
            <div class="bot-header">
                <label style="cursor: pointer;"><input type="checkbox" id="aiMode" checked> 봇 대전 활성화</label>
            </div>
            <div class="config-row">
                <select id="botPreset" onchange="applyPreset()" style="padding: 4px; border-radius: 4px;">
                    <option value="easy">쉬움</option>
                    <option value="normal" selected>보통</option>
                    <option value="hard">어려움</option>
                </select>
                <div class="slider-box">깊이: <b id="depthVal" style="width:12px; display:inline-block">1</b> <input type="range" id="botDepth" min="1" max="2" value="1" oninput="updateBotUI()"></div>
                <div class="slider-box">수비: <b id="defVal" style="width:25px; display:inline-block">1.1</b> <input type="range" id="botDefense" min="0.5" max="2.5" step="0.1" value="1.1" oninput="updateBotUI()"></div>
            </div>
        </div>
    </div>

    <div id="timer">00:00</div>
    <div id="status">대국을 시작하세요.</div>
    <div class="forbidden-msg" id="msg"></div>

    <div class="canvas-container">
        <canvas id="omokCanvas" width="600" height="600"></canvas>
    </div>

    <div class="buttons">
        <button id="undoBtn" onclick="undo()" disabled>무르기</button>
        <button id="actionBtn" class="start" onclick="handleAction()">게임 시작</button>
        <button onclick="location.reload()">초기화</button>
    </div>

    <script>
        const canvas = document.getElementById('omokCanvas');
        const ctx = canvas.getContext('2d');
        const statusDisplay = document.getElementById('status');
        const timerDisplay = document.getElementById('timer');
        const msgDisplay = document.getElementById('msg');
        const actionBtn = document.getElementById('actionBtn');
        
        const size = 15, padding = 40, cellSize = (canvas.width - padding * 2) / (size - 1);
        let board = Array.from({ length: size }, () => Array(size).fill(0));
        let history = [], currentPlayer = 1;
        let gameOver = true, isPaused = false, timerInterval = null, currentTurnTime = 0;
        let lastForbiddenMove = null;

        const isFour = (l) => /XXXX_| _XXXX|X_XXX|XX_XX|XXX_X/.test(l);
        const isOpenThree = (l) => /_XXX__|__XXX_|_X_XX_|_XX_X_/.test(l);
        const isOverline = (l) => /XXXXXX/.test(l);

        // 하단 통합 버튼 핸들러
        function handleAction() {
            if (gameOver) {
                startGame();
            } else {
                togglePause();
            }
        }

        function startGame() {
            board = Array.from({ length: size }, () => Array(size).fill(0));
            history = []; currentPlayer = 1; gameOver = false; isPaused = false;
            document.getElementById('undoBtn').disabled = true;
            
            // 버튼 상태 변경: 시작 -> 일시정지
            actionBtn.innerText = "일시정지";
            actionBtn.className = "pause";
            
            msgDisplay.innerText = ""; lastForbiddenMove = null;
            currentTurnTime = parseInt(document.getElementById('timeInput').value);
            startTimer(); updateStatus(); draw();
        }

        function togglePause() {
            if (gameOver) return;
            isPaused = !isPaused;
            if (isPaused) {
                actionBtn.innerText = "계속하기";
                actionBtn.className = "resume";
                statusDisplay.innerText = "일시정지 중";
            } else {
                actionBtn.innerText = "일시정지";
                actionBtn.className = "pause";
                updateStatus();
            }
        }

        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (!gameOver && !isPaused) {
                    currentTurnTime--; updateTimerDisplay();
                    if (currentTurnTime <= 0) endGame((currentPlayer === 1 ? "백색" : "흑색") + " 승리! (시간 초과)");
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const m = Math.floor(currentTurnTime / 60).toString().padStart(2, '0');
            const s = (currentTurnTime % 60).toString().padStart(2, '0');
            timerDisplay.innerText = `${m}:${s}`;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#333"; ctx.lineWidth = 1;
            for (let i = 0; i < size; i++) {
                ctx.beginPath(); ctx.moveTo(padding, padding + i * cellSize); ctx.lineTo(canvas.width - padding, padding + i * cellSize); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(padding + i * cellSize, padding); ctx.lineTo(padding + i * cellSize, canvas.height - padding); ctx.stroke();
            }
            ctx.fillStyle = "#333";
            [3, 7, 11].forEach(r => [3, 7, 11].forEach(c => { ctx.beginPath(); ctx.arc(padding + r * cellSize, padding + c * cellSize, 4, 0, Math.PI * 2); ctx.fill(); }));
            if (lastForbiddenMove) drawForbiddenDebug(lastForbiddenMove);
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) if (board[r][c] !== 0) drawStone(r, c, board[r][c]);
            }
        }

        function drawStone(r, c, type) {
            const x = padding + c * cellSize, y = padding + r * cellSize;
            ctx.beginPath(); ctx.arc(x, y, cellSize * 0.42, 0, Math.PI * 2);
            const grad = ctx.createRadialGradient(x-5, y-5, 2, x, y, cellSize*0.4);
            if (type === 1) { grad.addColorStop(0, "#666"); grad.addColorStop(1, "#000"); }
            else { grad.addColorStop(0, "#fff"); grad.addColorStop(1, "#ccc"); }
            ctx.fillStyle = grad; ctx.shadowBlur = 4; ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawForbiddenDebug(move) {
            const { r, c, dirs } = move;
            ctx.save(); ctx.strokeStyle = "rgba(231, 76, 60, 0.5)"; ctx.lineWidth = 10; ctx.lineCap = "round";
            dirs.forEach(([dr, dc]) => {
                ctx.beginPath();
                ctx.moveTo(padding + (c - dc * 3) * cellSize, padding + (r - dr * 3) * cellSize);
                ctx.lineTo(padding + (c + dc * 3) * cellSize, padding + (r + dr * 3) * cellSize);
                ctx.stroke();
            });
            ctx.strokeStyle = "#e74c3c"; ctx.lineWidth = 3;
            const x = padding + c * cellSize, y = padding + r * cellSize, d = 10;
            ctx.beginPath(); ctx.moveTo(x-d, y-d); ctx.lineTo(x+d, y+d); ctx.moveTo(x+d, y-d); ctx.lineTo(x-d, y+d); ctx.stroke();
            ctx.restore();
        }

        canvas.addEventListener('click', (e) => {
            if (gameOver || isPaused || (document.getElementById('aiMode').checked && currentPlayer === 2)) return;
            const rect = canvas.getBoundingClientRect();
            const scale = canvas.width / rect.width;
            const col = Math.round(((e.clientX - rect.left) * scale - padding) / cellSize);
            const row = Math.round(((e.clientY - rect.top) * scale - padding) / cellSize);
            lastForbiddenMove = null; 
            if (placeStone(row, col)) if (document.getElementById('aiMode').checked && !gameOver) setTimeout(makeBotMove, 400);
        });

        function getForbiddenInfo(r, c, color) {
            const isBlackCheck = document.getElementById('blackForbidden').checked;
            const isWhiteCheck = document.getElementById('whiteForbidden').checked;
            if (color === 1 && !isBlackCheck) return null;
            if (color === 2 && !isWhiteCheck) return null;

            let o3Dirs = [], o4Dirs = [], hasOverline = false;
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (let [dr, dc] of dirs) {
                const line = getLineString(r, c, dr, dc, color);
                if (isOverline(line)) { hasOverline = true; break; } 
                else if (isFour(line)) o4Dirs.push([dr, dc]);
                else if (isOpenThree(line)) o3Dirs.push([dr, dc]);
            }
            if (hasOverline) return { type: "육목", dirs: dirs };
            const is44 = o4Dirs.length >= 2;
            const is33 = o3Dirs.length >= 2;
            const is34 = o4Dirs.length >= 1 && o3Dirs.length >= 1;
            if (is44 || is33 || is34) {
                let type = is44 ? "4-4" : (is33 ? "3-3" : "3-4");
                return { type, dirs: [...o3Dirs, ...o4Dirs] };
            }
            return null;
        }

        function getLineString(r, c, dr, dc, color) {
            let s = ""; 
            for (let i = -5; i <= 5; i++) {
                let nr = r+dr*i, nc = c+dc*i;
                if (nr === r && nc === c) s += "X"; 
                else if (nr<0 || nr>=size || nc<0 || nc>=size) s += "O";
                else if (board[nr][nc] === color) s += "X";
                else if (board[nr][nc] === 0) s += "_";
                else s += "O";
            }
            return s;
        }

        function placeStone(r, c) {
            if (r < 0 || r >= size || c < 0 || c >= size || board[r][c] !== 0) return false;
            const fInfo = getForbiddenInfo(r, c, currentPlayer);
            if (fInfo) { 
                msgDisplay.innerText = `[${currentPlayer === 1 ? '흑' : '백'} 금수] ${fInfo.type}!`; 
                lastForbiddenMove = { r, c, dirs: fInfo.dirs }; 
                draw(); return false; 
            }
            msgDisplay.innerText = ""; board[r][c] = currentPlayer; history.push({r, c, p: currentPlayer});
            document.getElementById('undoBtn').disabled = false;
            if (checkWin(r, c)) { draw(); endGame((currentPlayer === 1 ? "흑색" : "백색") + " 승리!"); return true; }
            currentPlayer = (currentPlayer === 1) ? 2 : 1; currentTurnTime = parseInt(document.getElementById('timeInput').value);
            updateStatus(); startTimer(); draw(); return true;
        }

        function checkWin(r, c) {
            const color = board[r][c];
            const isCheck = (color === 1) ? document.getElementById('blackForbidden').checked : document.getElementById('whiteForbidden').checked;
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (let [dr, dc] of dirs) {
                let count = 1;
                for (let s of [1, -1]) {
                    let nr = r+dr*s, nc = c+dc*s;
                    while(nr>=0 && nr<size && nc>=0 && nc<size && board[nr][nc] === color) { count++; nr+=dr*s; nc+=dc*s; }
                }
                if (isCheck ? count === 5 : count >= 5) return true;
            }
            return false;
        }

        function makeBotMove() {
            if (gameOver || isPaused) return;
            const db = parseFloat(document.getElementById('botDefense').value);
            let best = {r: -1, c: -1, score: -Infinity};
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (board[r][c] === 0 && !getForbiddenInfo(r, c, 2)) {
                        let score = evaluate(r, c, db);
                        if (score > best.score) best = {r, c, score};
                    }
                }
            }
            if (best.r !== -1) placeStone(best.r, best.c);
        }

        function evaluate(r, c, db) {
            let s = 0; const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (let [dr, dc] of dirs) {
                const line = getLineString(r, c, dr, dc, 2);
                s += weight(line);
                s += weight(getLineString(r, c, dr, dc, 1)) * db;
            }
            return s + (7 - Math.abs(7-r)) + (7 - Math.abs(7-c));
        }

        function weight(l) {
            if (l.includes("XXXXXX")) return -5000;
            if (l.includes("XXXXX")) return 100000;
            if (l.includes("_XXXX_")) return 10000;
            if (l.includes("XXXX_") || l.includes("_XXXX") || l.includes("X_XXX") || l.includes("XX_XX")) return 2500;
            if (l.includes("_XXX__") || l.includes("__XXX_") || l.includes("_X_XX_") || l.includes("_XX_X_")) return 1500;
            return 0;
        }

        function updateStatus() { statusDisplay.innerText = (currentPlayer === 1 ? "흑색" : "백색") + " 차례"; }
        function endGame(m) { 
            gameOver = true; 
            statusDisplay.innerText = m; 
            clearInterval(timerInterval); 
            // 게임 종료 후 버튼 다시 시작으로 변경
            actionBtn.innerText = "게임 시작";
            actionBtn.className = "start";
        }
        function undo() { if (history.length > 0) { const s = document.getElementById('aiMode').checked ? 2 : 1; for(let i=0; i<s; i++) if(history.length > 0) { const l = history.pop(); board[l.r][l.c] = 0; currentPlayer = l.p; } lastForbiddenMove = null; draw(); updateStatus(); } }
        function applyPreset() { const p = document.getElementById('botPreset').value, d = document.getElementById('botDepth'), df = document.getElementById('botDefense'); if (p === 'easy') { d.value = 1; df.value = 0.7; } else if (p === 'normal') { d.value = 1; df.value = 1.1; } else if (p === 'hard') { d.value = 2; df.value = 1.8; } updateBotUI(); }
        function updateBotUI() { document.getElementById('depthVal').innerText = document.getElementById('botDepth').value; document.getElementById('defVal').innerText = document.getElementById('botDefense').value; }
        draw();
    </script>
</body>
</html>
