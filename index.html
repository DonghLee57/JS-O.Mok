<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/png" href="./icon.png">
    <title>오목 Pro v5.6 (Mobile)</title>
    <style>
        :root { --primary: #34495e; --accent: #e74c3c; --bg: #f4f7f6; }
        body { 
            display: flex; flex-direction: column; align-items: center; 
            background-color: var(--bg); font-family: 'Malgun Gothic', sans-serif; 
            margin: 0; padding: 10px; box-sizing: border-box;
            touch-action: manipulation; /* 더블탭 줌 방지 */
        }
        h1 { font-size: 1.5rem; margin: 10px 0; }
        
        /* 컨트롤 패널 반응형 설계 */
        .controls { 
            margin-bottom: 15px; padding: 15px; background: white; 
            border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); 
            display: flex; flex-direction: column; gap: 12px; 
            width: 95%; max-width: 650px; box-sizing: border-box;
        }
        .config-row { 
            display: flex; gap: 8px; align-items: center; 
            flex-wrap: wrap; justify-content: center; font-size: 0.9rem;
        }
        .bot-panel { background: #ebf2f6; padding: 10px; border-radius: 8px; display: flex; flex-direction: column; gap: 8px; }
        .slider-box { display: flex; align-items: center; gap: 5px; font-size: 0.85rem; flex: 1; min-width: 140px; }
        
        #status { font-size: 1.1rem; font-weight: bold; margin: 5px 0; color: var(--primary); }
        #timer { font-family: monospace; color: var(--accent); font-size: 1.5rem; font-weight: bold; }
        
        /* 캔버스 반응형: 화면 너비에 맞춤 */
        .canvas-container {
            width: 100%; max-width: 600px; aspect-ratio: 1 / 1;
            display: flex; justify-content: center;
        }
        canvas { 
            background-color: #e3a05b; box-shadow: 0 8px 25px rgba(0,0,0,0.2); 
            cursor: pointer; border-radius: 4px; 
            width: 100%; height: auto; /* CSS로 크기 조절 */
        }

        .buttons { margin-top: 15px; display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
        button { padding: 10px 15px; font-size: 0.9rem; cursor: pointer; background-color: var(--primary); color: white; border: none; border-radius: 6px; }
        button#pauseBtn { background-color: #f39c12; }
        button:disabled { background-color: #bdc3c7; }
        
        .forbidden-msg { color: var(--accent); font-size: 1rem; height: 24px; font-weight: bold; margin-top: 5px; text-align: center; }
        .check-group { border: 1px solid #ddd; padding: 5px 8px; border-radius: 5px; background: #fff; display: flex; gap: 8px; }

        @media (max-width: 480px) {
            h1 { font-size: 1.2rem; }
            .config-row { gap: 5px; }
            button { padding: 8px 12px; font-size: 0.8rem; }
        }
    </style>
</head>
<body>

    <h1>오목 <small style="font-size: 0.5em; color: #888;">v5.6 Pro Mobile</small></h1>
    
    <div class="controls">
        <div class="config-row">
            <div>시간: <input type="number" id="timeInput" value="30" min="5" style="width:35px">s</div>
            <label><input type="checkbox" id="aiMode" checked> 봇</label>
            <div class="check-group">
                <label><input type="checkbox" id="blackForbidden" checked> 흑 금수</label>
                <label><input type="checkbox" id="whiteForbidden"> 백 금수</label>
            </div>
            <button onclick="startGame()" style="background-color: #27ae60;">시작</button>
        </div>

        <div class="bot-panel">
            <div class="config-row">
                <select id="botPreset" onchange="applyPreset()">
                    <option value="easy">쉬움</option>
                    <option value="normal" selected>보통</option>
                    <option value="hard">어려움</option>
                </select>
                <div class="slider-box">깊이: <b id="depthVal">1</b> <input type="range" id="botDepth" min="1" max="2" value="1" style="width:60px" oninput="updateBotUI()"></div>
                <div class="slider-box">수비: <b id="defVal">1.1</b> <input type="range" id="botDefense" min="0.5" max="2.5" step="0.1" value="1.1" style="width:60px" oninput="updateBotUI()"></div>
            </div>
        </div>
    </div>

    <div id="timer">00:00</div>
    <div id="status">게임을 시작하세요.</div>
    <div class="forbidden-msg" id="msg"></div>

    <div class="canvas-container">
        <canvas id="omokCanvas" width="600" height="600"></canvas>
    </div>

    <div class="buttons">
        <button id="undoBtn" onclick="undo()" disabled>무르기</button>
        <button id="pauseBtn" onclick="togglePause()" disabled>일시정지</button>
        <button onclick="location.reload()">초기화</button>
    </div>

    <script>
        const canvas = document.getElementById('omokCanvas');
        const ctx = canvas.getContext('2d');
        const statusDisplay = document.getElementById('status');
        const timerDisplay = document.getElementById('timer');
        const msgDisplay = document.getElementById('msg');
        
        const size = 15, padding = 40, cellSize = (canvas.width - padding * 2) / (size - 1);
        let board = Array.from({ length: size }, () => Array(size).fill(0));
        let history = [], currentPlayer = 1;
        let gameOver = true, isPaused = false, timerInterval = null, currentTurnTime = 0;
        let lastForbiddenMove = null;

        const isFour = (l) => /XXXX_| _XXXX|X_XXX|XX_XX|XXX_X/.test(l);
        const isOpenThree = (l) => /_XXX__|__XXX_|_X_XX_|_XX_X_/.test(l);
        const isOverline = (l) => /XXXXXX/.test(l);

        function startGame() {
            board = Array.from({ length: size }, () => Array(size).fill(0));
            history = []; currentPlayer = 1; gameOver = false; isPaused = false;
            document.getElementById('undoBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('pauseBtn').innerText = "일시정지";
            msgDisplay.innerText = ""; lastForbiddenMove = null;
            currentTurnTime = parseInt(document.getElementById('timeInput').value);
            startTimer(); updateStatus(); draw();
        }

        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (!gameOver && !isPaused) {
                    currentTurnTime--; updateTimerDisplay();
                    if (currentTurnTime <= 0) endGame((currentPlayer === 1 ? "백색" : "흑색") + " 승리! (시간 초과)");
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            const m = Math.floor(currentTurnTime / 60).toString().padStart(2, '0');
            const s = (currentTurnTime % 60).toString().padStart(2, '0');
            timerDisplay.innerText = `${m}:${s}`;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = "#333"; ctx.lineWidth = 1;
            for (let i = 0; i < size; i++) {
                ctx.beginPath(); ctx.moveTo(padding, padding + i * cellSize); ctx.lineTo(canvas.width - padding, padding + i * cellSize); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(padding + i * cellSize, padding); ctx.lineTo(padding + i * cellSize, canvas.height - padding); ctx.stroke();
            }
            ctx.fillStyle = "#333";
            [3, 7, 11].forEach(r => [3, 7, 11].forEach(c => { ctx.beginPath(); ctx.arc(padding + r * cellSize, padding + c * cellSize, 4, 0, Math.PI * 2); ctx.fill(); }));
            if (lastForbiddenMove) drawForbiddenDebug(lastForbiddenMove);
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) if (board[r][c] !== 0) drawStone(r, c, board[r][c]);
            }
        }

        function drawStone(r, c, type) {
            const x = padding + c * cellSize, y = padding + r * cellSize;
            ctx.beginPath(); ctx.arc(x, y, cellSize * 0.42, 0, Math.PI * 2);
            const grad = ctx.createRadialGradient(x-5, y-5, 2, x, y, cellSize*0.4);
            if (type === 1) { grad.addColorStop(0, "#666"); grad.addColorStop(1, "#000"); }
            else { grad.addColorStop(0, "#fff"); grad.addColorStop(1, "#ccc"); }
            ctx.fillStyle = grad; ctx.shadowBlur = 4; ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawForbiddenDebug(move) {
            const { r, c, dirs } = move;
            ctx.save(); ctx.strokeStyle = "rgba(231, 76, 60, 0.5)"; ctx.lineWidth = 8; ctx.lineCap = "round";
            dirs.forEach(([dr, dc]) => {
                ctx.beginPath();
                ctx.moveTo(padding + (c - dc * 3) * cellSize, padding + (r - dr * 3) * cellSize);
                ctx.lineTo(padding + (c + dc * 3) * cellSize, padding + (r + dr * 3) * cellSize);
                ctx.stroke();
            });
            ctx.restore();
        }

        // 모바일 좌표 계산 최적화
        canvas.addEventListener('click', (e) => {
            if (gameOver || isPaused || (document.getElementById('aiMode').checked && currentPlayer === 2)) return;
            const rect = canvas.getBoundingClientRect();
            // 화면 크기와 실제 캔버스 해상도 비율 계산
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const col = Math.round(((e.clientX - rect.left) * scaleX - padding) / cellSize);
            const row = Math.round(((e.clientY - rect.top) * scaleY - padding) / cellSize);
            
            lastForbiddenMove = null;
            if (placeStone(row, col)) if (document.getElementById('aiMode').checked && !gameOver) setTimeout(makeBotMove, 400);
        });

        function getForbiddenInfo(r, c, color) {
            const isBlackCheck = document.getElementById('blackForbidden').checked;
            const isWhiteCheck = document.getElementById('whiteForbidden').checked;
            if (color === 1 && !isBlackCheck) return null;
            if (color === 2 && !isWhiteCheck) return null;

            board[r][c] = color;
            let o3Dirs = new Set(), o4Dirs = new Set(), hasOverline = false;
            const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (let [dr, dc] of dirs) {
                const line = getLineString(r, c, dr, dc, color);
                if (isOverline(line)) hasOverline = true;
                if (isFour(line)) o4Dirs.add(`${dr},${dc}`);
                if (isOpenThree(line)) o3Dirs.add(`${dr},${dc}`);
            }
            board[r][c] = 0;
            if (hasOverline) return { type: "육목", dirs: dirs };
            if (o4Dirs.size >= 2) return { type: "4-4", dirs: Array.from(o4Dirs).map(s => s.split(',').map(Number)) };
            if (o3Dirs.size >= 2) return { type: "3-3", dirs: Array.from(o3Dirs).map(s => s.split(',').map(Number)) };
            return null;
        }

        function placeStone(r, c) {
            if (r < 0 || r >= size || c < 0 || c >= size || board[r][c] !== 0) return false;
            const fInfo = getForbiddenInfo(r, c, currentPlayer);
            if (fInfo) { 
                msgDisplay.innerText = `[${currentPlayer === 1 ? '흑' : '백'} 금수] ${fInfo.type}!`; 
                lastForbiddenMove = { r, c, dirs: fInfo.dirs }; draw(); return false; 
            }
            msgDisplay.innerText = ""; board[r][c] = currentPlayer; history.push({r, c, p: currentPlayer});
            document.getElementById('undoBtn').disabled = false; draw();
            if (checkWin(r, c)) { endGame((currentPlayer === 1 ? "흑색" : "백색") + " 승리!"); return true; }
            currentPlayer = (currentPlayer === 1) ? 2 : 1; currentTurnTime = parseInt(document.getElementById('timeInput').value);
            updateStatus(); startTimer(); return true;
        }

        function getLineString(r, c, dr, dc, color) {
            let s = ""; const temp = board[r][c]; board[r][c] = color;
            for (let i = -5; i <= 5; i++) {
                let nr = r+dr*i, nc = c+dc*i;
                if (nr<0 || nr>=size || nc<0 || nc>=size) s += "O";
                else if (board[nr][nc] === color) s += "X";
                else if (board[nr][nc] === 0) s += "_";
                else s += "O";
            }
            board[r][c] = temp; return s;
        }

        function checkWin(r, c) {
            const color = board[r][c]; const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            const isCheck = (color === 1) ? document.getElementById('blackForbidden').checked : document.getElementById('whiteForbidden').checked;
            for (let [dr, dc] of dirs) {
                let count = 1;
                for (let s of [1, -1]) {
                    let nr = r+dr*s, nc = c+dc*s;
                    while(nr>=0 && nr<size && nc>=0 && nc<size && board[nr][nc] === color) { count++; nr+=dr*s; nc+=dc*s; }
                }
                if (isCheck ? count === 5 : count >= 5) return true;
            }
            return false;
        }

        function makeBotMove() {
            if (gameOver || isPaused) return;
            const db = parseFloat(document.getElementById('botDefense').value);
            let best = {r: -1, c: -1, score: -Infinity};
            for (let r = 0; r < size; r++) {
                for (let c = 0; c < size; c++) {
                    if (board[r][c] === 0 && !getForbiddenInfo(r, c, 2)) {
                        let score = evaluate(r, c, db);
                        if (score > best.score) best = {r, c, score};
                    }
                }
            }
            if (best.r !== -1) placeStone(best.r, best.c);
        }

        function evaluate(r, c, db) {
            let s = 0; const dirs = [[0,1],[1,0],[1,1],[1,-1]];
            for (let [dr, dc] of dirs) {
                s += weight(getLineString(r, c, dr, dc, 2));
                s += weight(getLineString(r, c, dr, dc, 1)) * db;
            }
            return s + (7 - Math.abs(7-r)) + (7 - Math.abs(7-c));
        }

        function weight(l) {
            if (l.includes("XXXXXX")) return -5000;
            if (l.includes("XXXXX")) return 100000;
            if (l.includes("_XXXX_")) return 10000;
            if (l.includes("XXXX_") || l.includes("_XXXX") || l.includes("X_XXX") || l.includes("XX_XX")) return 2500;
            if (l.includes("_XXX__") || l.includes("__XXX_") || l.includes("_X_XX_") || l.includes("_XX_X_")) return 1500;
            return 0;
        }

        function togglePause() { isPaused = !isPaused; document.getElementById('pauseBtn').innerText = isPaused ? "계속" : "일시정지"; updateStatus(); }
        function updateStatus() { statusDisplay.innerText = isPaused ? "일시정지 중" : (currentPlayer === 1 ? "흑색 차례" : "백색 차례"); }
        function endGame(m) { gameOver = true; statusDisplay.innerText = m; clearInterval(timerInterval); }
        function undo() { if (history.length > 0) { const s = document.getElementById('aiMode').checked ? 2 : 1; for(let i=0; i<s; i++) if(history.length > 0) { const l = history.pop(); board[l.r][l.c] = 0; currentPlayer = l.p; } lastForbiddenMove = null; draw(); updateStatus(); } }
        function applyPreset() { const p = document.getElementById('botPreset').value, d = document.getElementById('botDepth'), df = document.getElementById('botDefense'); if (p === 'easy') { d.value = 1; df.value = 0.7; } else if (p === 'normal') { d.value = 1; df.value = 1.1; } else if (p === 'hard') { d.value = 2; df.value = 1.8; } updateBotUI(); }
        function updateBotUI() { document.getElementById('depthVal').innerText = document.getElementById('botDepth').value; document.getElementById('defVal').innerText = document.getElementById('botDefense').value; }
        draw();
    </script>
</body>
</html>
